from numba import njit, types, prangeimport ctypesfrom numba.extending import get_cython_function_addressimport numpy as npimport math@njit def integrate_quad(a, b, xs, ws, func1, func2):    return (b-a)/2 * np.sum(ws * func1((b-a)/2*xs + (a+b)/2) * func2((b-a)/2*xs + (a+b)/2))_dble = ctypes.c_doubleaddr = get_cython_function_address("scipy.special.cython_special", "__pyx_fuse_0_1eval_legendre")functype = ctypes.CFUNCTYPE(_dble, _dble, _dble)eval_legendre_float64_fn = functype(addr)# @njit("float64[:](float64,float64[:])")  @njitdef numba_eval_legendre_float64(n, x):      return eval_legendre_float64_fn(n, x)# @njit("float64[:](float64,float64[:],float64,float64)", looplift=False, parallel=False)@njitdef normPn(n,x,a=-1.0,b=1.0):    tmp = 0*x    for count in prange(x.size):        z = (b+a-2*x[count])/(a-b)        fact = np.sqrt((2*n+1)/(b-a)) #*(x>=a)*(x<=b)        # tmp[count] = sc.eval_legendre(n,z)*fact        tmp[count] = numba_eval_legendre_float64(n, z)*fact    return tmp    # @njit("float64[:](int64, float64[:], float64[:], float64[:,:,:], int64, float64[:,:])", parallel = True, looplift = True, fastmath = True)def make_phi(N_ang, ws, xs, u, M, edges):    output = xs*0    psi = np.zeros((N_ang, xs.size))    for ang in range(N_ang):        for count in range(xs.size):            idx = np.searchsorted(edges[:], xs[count])            if (idx == 0):                idx = 1            if (idx >= edges.size):                idx = edges.size - 1            for i in range(M+1):                psi[ang, count] += u[ang,idx-1,i] * normPn(i,xs[count:count+1],float(edges[idx-1]),float(edges[idx]))[0]    output = np.sum(np.multiply(psi.transpose(), ws), axis = 1)    return output@njit def surf_func(speed,u,space,j,side,xL,xR,N_space):#    print(side)    if j ==0:        B_right = 1/math.sqrt(xR-xL)        B_left = 1/math.sqrt(xR-xL)    else:         B_right = math.sqrt(2*j+1)/math.sqrt(xR-xL)         if j%2 ==0:                B_left = math.sqrt(2*j+1)/math.sqrt(xR-xL)         else:                B_left = -math.sqrt(2*j+1)/math.sqrt(xR-xL)    if speed == 0:        return 0    elif speed > 0 and side == "R":        return u[space,j]*B_right    elif speed > 0 and side =="L":        if space !=0:#            print(u[k-1,j])            return u[space-1,j]*B_right         else:            return 0    elif speed < 0 and side =="R":        if space != N_space-1:            return u[space+1,j]*B_left        else:            return 0    elif speed < 0 and side =="L":        return u[space,j]*B_left@njitdef LU_surf_func(u,space,N_space,mul,M,xL,xR,dxL,dxR):    sumright = 0    sumleft = 0    rightspeed = mul - dxR    leftspeed = mul-dxL    for j in range(0,M+1):        sumright += surf_func(rightspeed,u,space,j,"R",xL,xR,N_space)        sumleft += surf_func(leftspeed,u,space,j,"L",xL,xR,N_space)    LU = np.zeros(M+1).transpose()    for i in range(0,M+1):        if i == 0:            B_right = 1/math.sqrt(xR-xL)            B_left = 1/math.sqrt(xR-xL)        elif j>0:            B_right = math.sqrt(2*i+1)/math.sqrt(xR-xL)            if i%2 ==0:                B_left = math.sqrt(2*i+1)/math.sqrt(xR-xL)            else:                 B_left = -math.sqrt(2*i+1)/math.sqrt(xR-xL)        LU[i] = rightspeed*B_right*(sumright) - leftspeed*B_left*(sumleft)    return LU def find_nodes(xs_quad, edges):    # scheme = quadpy.c1.gauss_legendre(M+1)    ixx = xs_quad.size    xs_list = np.zeros(ixx*(edges.size-1))    for k in range(edges.size-1):        xL = edges[k]        xR = edges[k+1]        xs_list[k*ixx:(k+1)*ixx] = xL + (xs_quad + 1)*(xR - xL)/2    return xs_list